## 代码的表示形式
代码的表示形式 应该易于解析器生成， 也易于解释器使用。

代码的一种可行的表达形式 是一颗与语言的语法结构相匹配的树。

形式化语法规则：
> 给定"字母表"，"字符串"是由字母组成的一个字符序列。

- 在词法规则中，字母表中的每个元素就是字母，组成的字符串就是一个个单词，这些单词又叫作词素。
- 在上下文无关语法规则中，字母表中的每个元素就是词素，组成的字符串就是一个个表达式，这些表达式就是

## 语法规则
我们可以使用语法规则去生成字符串，这种方式创建的字符串被称为推导式，而规则被称为生成式。

生成式的组成：
- 头部：即名称
- 主体：一系列符号
	- 终止符：是一个独立的词素
	- 非终止符：对语法中另一条规则的引用，执行那条规则，然后将它生成的内容插入这里。

增强符号：
- 管道分隔符|：表示 or的意思
- 括号()：表示分组
- \*：表示前面的生成式 可以重复 0次或无数次
- +：表示前面的生成式 至少出现一次
- ？：表示可选生成式，可出现0次或1次，但不能出现多次

Lox符号：
- 字面量：数字、字符串、布尔值以及nil
- 一元表达式：前缀`!`执行逻辑非运算，`-`对数字符号取反
- 二元表达式：算术符+-\*/   逻辑运算符== != < <= > >=
- 括号：表示分组

Lox语法：
expression     → literal
               | unary
               | binary
               | grouping ;

literal        → NUMBER | STRING | "true" | "false" | "nil" ;
grouping       → "(" expression ")" ;
unary          → ( "-" | "!" ) expression ;
binary         → expression operator expression ;
operator       → "\=\="  | "!=" | "<" | "<=" | ">" | ">="
               | "+"  | "-"  | "\*" | "/" ;

## 处理语法树
不同的token类型有不同的处理行为，我们可以编写一长串类型测试去识别每一种类型，如：
```cpp
if (expr instanceof Expr.Binary) {
  // ...
} else if (expr instanceof Expr.Grouping) {
  // ...
} else // ...
```
也可以使用虚函数多态技术，给基类添加一个虚函数，然后每个子类实现该虚函数即可，但是它的扩展性很差，如下表，我们添加新行很容易，只需要定义一个新类即可，但是如果要添加一个新列，那么就要对每个类添加新方法。
![[Pasted image 20221013162743.png]]
如果使用函数式范型，那么不同类实现一个操作只需要定义一个函数，在该情况下，添加一列很容易，只需要新增一个函数即可，但是如果添加一行则很麻烦， 需要对每个函数都增加代码。
![[Pasted image 20221013163143.png]]

为了解决上述问题，我们可以使用访问者模式：
- 对基类定义accept方法，每个子类实现accept方法，accept接收访问者参数
- 每个访问者表示一类操作，在访问者内部，要实现对所有类的处理
具体范式：
```cpp
// 定义抽象类，类中有accept方法，接收访问者
abstract class Pastry {
    abstract void accept(PastryVisitor visitor); // 多态，可以接收很多访问者
  }

// 定义访问者接口，每个子类都要重写对每个类的处理函数
interface PastryVisitor {
    void visitBeignet(Beignet beignet); 
    void visitCruller(Cruller cruller);
  }
```

